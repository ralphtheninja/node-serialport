<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bindings/mock.js - Postman Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

    <a href="https://github.com/node-serialport/node-serialport" class="github-corner" aria-label="View source on Github">
        <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#e31c60; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    </a>
    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <!-- http://tholman.com/github-corners/ -->


<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BaseBinding.html">BaseBinding</a><ul class='methods'><li data-type='method'><a href="BaseBinding.html#.list">list</a></li><li data-type='method'><a href="BaseBinding.html#close">close</a></li><li data-type='method'><a href="BaseBinding.html#drain">drain</a></li><li data-type='method'><a href="BaseBinding.html#flush">flush</a></li><li data-type='method'><a href="BaseBinding.html#get">get</a></li><li data-type='method'><a href="BaseBinding.html#getBaudRate">getBaudRate</a></li><li data-type='method'><a href="BaseBinding.html#open">open</a></li><li data-type='method'><a href="BaseBinding.html#read">read</a></li><li data-type='method'><a href="BaseBinding.html#set">set</a></li><li data-type='method'><a href="BaseBinding.html#update">update</a></li><li data-type='method'><a href="BaseBinding.html#write">write</a></li></ul></li><li><a href="DarwinBinding.html">DarwinBinding</a></li><li><a href="LinuxBinding.html">LinuxBinding</a></li><li><a href="MockBinding.html">MockBinding</a></li><li><a href="Poller.html">Poller</a><ul class='methods'><li data-type='method'><a href="Poller.html#once">once</a></li><li data-type='method'><a href="Poller.html#poll">poll</a></li><li data-type='method'><a href="Poller.html#stop">stop</a></li></ul></li><li><a href="SerialPort.html">SerialPort</a><ul class='methods'><li data-type='method'><a href="SerialPort.html#.list">list</a></li><li data-type='method'><a href="SerialPort.html#close">close</a></li><li data-type='method'><a href="SerialPort.html#drain">drain</a></li><li data-type='method'><a href="SerialPort.html#flush">flush</a></li><li data-type='method'><a href="SerialPort.html#get">get</a></li><li data-type='method'><a href="SerialPort.html#open">open</a></li><li data-type='method'><a href="SerialPort.html#pause">pause</a></li><li data-type='method'><a href="SerialPort.html#read">read</a></li><li data-type='method'><a href="SerialPort.html#resume">resume</a></li><li data-type='method'><a href="SerialPort.html#set">set</a></li><li data-type='method'><a href="SerialPort.html#update">update</a></li><li data-type='method'><a href="SerialPort.html#write">write</a></li></ul></li><li><a href="WindowsBinding.html">WindowsBinding</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:close">close</a></li><li><a href="global.html#event:data">data</a></li><li><a href="global.html#event:error">error</a></li><li><a href="global.html#event:open">open</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Binding">Binding</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">bindings/mock.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
const debug = require('debug')('serialport:bindings:mock');
const Buffer = require('safe-buffer').Buffer;
const BaseBinding = require('./base');

let ports = {};
let serialNumber = 0;

function resolveNextTick(value) {
  return new Promise(resolve => process.nextTick(() => resolve(value)));
}

/**
 * Mock bindings for pretend serialport access
 */
class MockBinding extends BaseBinding {
  constructor(opt) {
    super(opt);
    this.pendingRead = null; // thunk for a promise or null
    this.isOpen = false;
    this.port = null;
    this.lastWrite = null;
    this.recording = Buffer.alloc(0);
    this.writeOperation = null; // in flight promise or null
  }

  // Reset mocks
  static reset() {
    ports = {};
  }

  // Create a mock port
  static createPort(path, opt) {
    serialNumber++;
    opt = Object.assign({
      echo: false,
      record: false,
      readyData: Buffer.from('READY')
    }, opt);

    ports[path] = {
      data: Buffer.alloc(0),
      echo: opt.echo,
      record: opt.record,
      readyData: Buffer.from(opt.readyData),
      info: {
        comName: path,
        manufacturer: 'The J5 Robotics Company',
        serialNumber,
        pnpId: undefined,
        locationId: undefined,
        vendorId: undefined,
        productId: undefined
      }
    };
    debug(serialNumber, 'created port', JSON.stringify({ path, opt }));
  }

  static list() {
    const info = Object.keys(ports).map((path) => {
      return ports[path].info;
    });
    return Promise.resolve(info);
  }

  // Emit data on a mock port
  emitData(data) {
    if (!this.isOpen) {
      throw new Error('Port must be open to pretend to receive data');
    }
    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data);
    }
    debug(this.serialNumber, 'emitting data - pending read:', Boolean(this.pendingRead));
    this.port.data = Buffer.concat([this.port.data, data]);
    if (this.pendingRead) {
      process.nextTick(this.pendingRead);
      this.pendingRead = null;
    }
  }

  open(path, opt) {
    debug(null, `opening path ${path}`);
    const port = this.port = ports[path];
    return super.open(path, opt)
      .then(resolveNextTick)
      .then(() => {
        if (!port) {
          return Promise.reject(new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`));
        }
        this.serialNumber = port.info.serialNumber;

        if (port.openOpt &amp;&amp; port.openOpt.lock) {
          return Promise.reject(new Error('Port is locked cannot open'));
        }

        if (this.isOpen) {
          return Promise.reject(new Error('Open: binding is already open'));
        }

        port.openOpt = Object.assign({}, opt);
        this.isOpen = true;
        debug(this.serialNumber, 'port is open');
        if (port.echo) {
          process.nextTick(() => {
            if (this.isOpen) {
              debug(this.serialNumber, 'emitting ready data');
              this.emitData(port.readyData);
            }
          });
        }
      });
  }

  close() {
    const port = this.port;
    debug(this.serialNumber, 'closing port');
    if (!port) {
      return Promise.reject(new Error('already closed'));
    }

    return super.close()
      .then(() => {
        delete port.openOpt;
        // reset data on close
        port.data = Buffer.alloc(0);
        debug(this.serialNumber, 'port is closed');
        delete this.port;
        delete this.serialNumber;
        this.isOpen = false;
        if (this.pendingRead) {
          this.pendingRead(new Error('port is closed'));
        }
      });
  }

  read(buffer, offset, length) {
    debug(this.serialNumber, 'reading', length, 'bytes');
    return super.read(buffer, offset, length)
      .then(resolveNextTick)
      .then(() => {
        if (!this.isOpen) {
          throw new Error('Read canceled');
        }
        if (this.port.data.length &lt;= 0) {
          return new Promise((resolve, reject) => {
            this.pendingRead = (err) => {
              if (err) { return reject(err) }
              this.read(buffer, offset, length).then(resolve, reject);
            };
          });
        }
        const data = this.port.data.slice(0, length);
        const readLength = data.copy(buffer, offset);
        this.port.data = this.port.data.slice(length);
        debug(this.serialNumber, 'read', readLength, 'bytes');
        return readLength;
      });
  }

  write(buffer) {
    debug(this.serialNumber, 'writing');
    if (this.writeOperation) {
      throw new Error('Overlapping writes are not supported and should be queued by the serialport object');
    }
    this.writeOperation = super.write(buffer)
      .then(resolveNextTick)
      .then(() => {
        if (!this.isOpen) {
          throw new Error('Write canceled');
        }
        const data = this.lastWrite = Buffer.from(buffer); // copy
        if (this.port.record) {
          this.recording = Buffer.concat([this.recording, data]);
        }
        if (this.port.echo) {
          process.nextTick(() => {
            if (this.isOpen) { this.emitData(data) }
          });
        }
        this.writeOperation = null;
        debug(this.serialNumber, 'writing finished');
      });
    return this.writeOperation;
  }

  update(opt) {
    return super.update(opt)
      .then(resolveNextTick)
      .then(() => {
        this.port.openOpt.baudRate = opt.baudRate;
      });
  }

  set(opt) {
    return super.set(opt)
      .then(resolveNextTick);
  }

  get() {
    return super.get()
      .then(resolveNextTick)
      .then(() => {
        return {
          cts: true,
          dsr: false,
          dcd: false
        };
      });
  }

  getBaudRate() {
    return super.getBaudRate()
      .then(resolveNextTick)
      .then(() => {
        return {
          baudRate: this.port.openOpt.baudRate
        };
      });
  }

  flush() {
    return super.flush()
      .then(resolveNextTick)
      .then(() => {
        this.port.data = Buffer.alloc(0);
      });
  }

  drain() {
    return super.drain()
      .then(() => this.writeOperation)
      .then(() => resolveNextTick());
  }
}

module.exports = MockBinding;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated at Wed Jun 27 2018 22:29:05 GMT-0400 (Eastern Daylight Time)
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
